#!/usr/bin/env python
import argparse
import json
import os.path
import re
import shlex
import subprocess
import sys
import logging
from commands import getoutput

FORMAT = '%(asctime)-15s %(levelname)-8s %(module)s %(message)s'
FORMAT = '%(levelname)-8s %(message)s'
logging.basicConfig(format=FORMAT)
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
info = logger.info
debug = logger.debug
warn = logger.warning
error = logger.error

try:
    basestring
except NameError:
    basestring = str


def freeze(obj):
    if isinstance(obj, dict):
        return freeze(tuple([freeze(x) for x in sorted(obj.items(), key=lambda i: i[0])]))
    if isinstance(obj, list):
        return tuple([freeze(x) for x in obj])
    if isinstance(obj, set):
        return frozenset({freeze(x) for x in obj})
    if isinstance(obj, tuple):
        return tuple([freeze(x) for x in obj])
    return obj


def extract_value(command, key):
    field = filter(lambda x: x[0] == key, command)
    return field[0][1] if field else None


class PathUtils(object):
    def __init__(self, cwd):
        if not cwd.endswith('/'):
            cwd = cwd + '/'
        self.directory = cwd
        self.db = self

    def relpath(self, path):
        if self.directory and (path.startswith(self.db.directory)
                               or path == self.db.directory):
            return os.path.relpath(path, self.directory)
        return path

    def resolve(self, path, cwd=None):
        if cwd is None:
            cwd = self.directory
        if not os.path.isabs(path):
            path = os.path.join(cwd, path)
        return os.path.normcase(os.path.normpath(path))


class CompilationDatabase(PathUtils):
    def __init__(self, infile, outfile):
        super(self.__class__, self).__init__('')
        self.targets = {}
        self.sources = {}
        self.objects = {}
        self.linkings = {}
        self.commands = {}
        self.command = []
        self.input = infile
        filename = os.path.realpath(infile.name)
        if os.path.isfile(filename):
            self.cmake_filename = filename
            self.directory = os.path.dirname(filename) + '/'
        else:
            self.cmake_filename = 'autogenerated'
            self.directory = ''

    def parse_command(self, command, cwd, file_):
        if isinstance(command, basestring):
            command = shlex.split(command)
        words = iter(command)
        compiler = os.path.basename(next(words))  # remove the initial 'cc' / 'c++'
        if compiler.startswith('python'):
            compiler = os.path.basename(next(words))

        options = []
        definitions = []
        includes = []
        system_includes = set()
        iquote_includes = set()
        libs = set()
        linkage = 'EXECUTABLE'
        target = ''
        missing_depends = []

        if compiler == 'ccache':
            compiler = 'clang'
        if compiler == 'glib-genmarshal':
            for word in words:
                if word == '--output':
                    linkage = 'SOURCE'
                    target = next(words)
                    #options.append(word)
                    #options.append(target)
                elif word.startswith('-'):
                    options.append(word)

        if compiler == 'dbus-binding-tool':
            for word in words:
                if word.startswith('--output='):
                    linkage = 'SOURCE'
                    target = word[len('--output='):]
                elif word.startswith('-'):
                    options.append(word)

        if compiler.endswith("ar"):
            for word in words:
                if not target:
                    if word.startswith('-'):
                        if 'c' in word:
                            linkage = 'STATIC'
                            target = next(words)
                    elif 'c' in word:
                        linkage = 'STATIC'
                        target = next(words)
                    else:
                        options.append(word)

        for word in words:
            if word == '-o':
                target = next(words)
            elif word.startswith('-I'):
                include = word[2:]
                includes.append(self.resolve(include, cwd))
            elif word == '-isystem':
                include = next(words)
                include = self.resolve(include, cwd)
                if include not in includes:
                    includes.append(include)
                system_includes.add(include)
            elif word == '-iquote':
                include = next(words)
                include = self.resolve(include)
                if include not in includes:
                    includes.append(include)
                iquote_includes.add(include)
            elif word.startswith('-D'):
                define = word[2:]
                if define.find('=') > 0:
                    name, value = define.split('=', 1)
                    if value:
                        define = '%s="%s"' % (name, value)
                definitions.append(define)
            elif word == '-c':
                linkage = 'OBJECT'
            elif word in ['-arch', '-include', '-x']:
                options.append(word)
                options.append(next(words))
            elif word in ['-MM', '-MQ', '-M', '-MP', '-MG']:
                continue
            elif word in ['-MT', '-MF', '-MQ', '-MD', '-MMD']:
                next(words)
            elif word.startswith('-L'):
                libs.add(word if len(word) > 2 else ('-L'+next(words)))
            elif word.startswith('-l'):
                libs.add(word[2:] or next(words))
            elif word in ['-g', '-O1', '-O2', '-O3']:
                continue
            elif word == '-O':
                next(words)
            elif word.startswith('-m'):
                options.append(word)
                libs.add(word)
            elif word == '-shared':
                options.append(word)
                linkage = 'SHARED'
            elif word.startswith('-'):
                options.append(word)

        config = {
            'cwd': cwd,
            'compiler': compiler,
            'linkage': linkage,
        }
        if libs:
            config['libs'] = freeze(libs)
        if options:
            config['options'] = freeze(options)
        if definitions:
            config['definitions'] = freeze(definitions)
        if includes:
            config['includes'] = freeze(includes)
        if system_includes:
            config['system_includes'] = freeze(system_includes)
        if iquote_includes:
            config['iquote_includes'] = freeze(iquote_includes)
        if linkage == 'OBJECT':
            missing_depends = self.find_dependencies(compiler, file_, config)
            if missing_depends:
                warn("OBJECT %-25s depends on missing %s"
                     % (self.relpath(target), ' '.join(missing_depends)))
        return config, target, missing_depends

    def find_dependencies(self, compiler, file_, config):
        cwd = config['cwd']
        if not cwd.endswith('/'):
            cwd += '/'
        if not os.path.isabs(file_):
            file_ = cwd + file_
        if not os.path.exists(file_):
            return [file_]

        def parameters(delimiter, name):
            parts = config.get(name)
            return '' if not parts else delimiter + (delimiter.join(parts))

        dep_command = "{} {} {} {} {} -MM -MG {}".format(
            compiler,
            parameters(' -D', 'definitions'),
            parameters(' -I', 'includes'),
            parameters(' -isystem', 'system_includes'),
            parameters(' -iquote', 'iquote_includes'),
            file_,
        )
        depends = getoutput(dep_command)
        if depends:
            depend_list = depends.split(': ', 1)[1].replace('\\\n  ', '').split(' ')
            depend_list = [f if os.path.isabs(f) else cwd + f for f in depend_list]
            debug('Files relative to %s\n\t%s' % (self.directory, '\n\t'.join(
                filter(lambda x: not x.startswith('/usr/'), depend_list))))
            depend_list = [os.path.relpath(f, self.directory) for f in depend_list]
            local_depends = filter(lambda x: not x.startswith('../'), depend_list)
            missing_depends = filter(lambda x: not os.path.exists(x), local_depends)
            return [self.directory + f for f in missing_depends]

    def read(self):
        database = json.load(self.input)
        for entry in database:
            self.read_command(entry)

    def read_command(self, entry):
        cwd = entry.get('directory', self.directory)
        file_ = self.resolve(entry['file'], cwd)
        cmd = None
        arguments = shlex.split(entry.get('command', ''))
        arguments = entry.get('arguments', arguments)
        cmd, target, missing_depends = self.parse_command(arguments, cwd, file_)
        if cmd:
            cmd_id = self.update_command_index(cmd)
            target = self.resolve(target, cwd)
            linkage = cmd.get('linkage')
            self.update_target_index(target, cmd_id, file_, linkage)
        for depend in missing_depends:
            debug('Update missing_depends for cmd #%s: %s' % (cmd_id, depend))
            self.command[cmd_id].setdefault('missing_depends', set()).add(depend)
        return cmd

    def update_command_index(self, cmd):
        command = freeze(cmd)
        cmd_id = self.commands.get(command)
        if cmd_id is None:
            cmd_id = len(self.command)
            self.commands[command] = cmd_id
            self.command.append(cmd)
        return cmd_id

    def update_target_index(self, target, cmd_id, file_, linkage):
        debug("entry %-35s cmd #%s => %-10s %s"
             % (self.relpath(file_), cmd_id, linkage, self.relpath(target)))
        self.sources.setdefault(file_, {})[target] = cmd_id
        self.objects.setdefault(target, {})[file_] = cmd_id
        self.targets.setdefault(cmd_id, {}).setdefault(target, set()).add(file_)
        if linkage not in ('OBJECT', None):
            self.update_linking_index(target, cmd_id, file_)

    def update_linking_index(self, target, cmd_id, file_):
        debug("Add linked target %s from %s"
              % (self.relpath(target), self.relpath(file_)))
        self.linkings.setdefault(target, {}).setdefault(cmd_id, set()).add(file_)


class CmakeGenerator(PathUtils):

    used_names = {"": ""}
    disallowed_characters = re.compile("[^A-Za-z0-9_.+\\-]")
    generators = {}

    def __init__(self, database, name, cwd, single_file=False):
        super(self.__class__, self).__init__(cwd)
        self.db = database
        self.name = name
        self.output = open(os.path.join(cwd, 'CMakeLists.txt'), 'w')
        self.single_file = single_file
        self.output.write('cmake_minimum_required(VERSION 2.8.8)\n')
        info("write project %s in directory \t%s" % (name, self.directory))
        self.output.write('project({} LANGUAGES C CXX)\n\n'.format(name))

    def custom_target_output_args(self, compiler, target):
        custom_target_output_config = {
            'glib-genmarshal': '--output ',
            'dbus-binding-tool': '--output=',
        }
        prefix = custom_target_output_config.get(compiler, ' ')
        return prefix + self.cmake_resolve_binary(target)

    def cmake_resolve_source(self, path):
        return "${CMAKE_CURRENT_SOURCE_DIR}/%s" % self.relpath(path)

    def cmake_resolve_binary(self, path):
        return "${CMAKE_CURRENT_BINARY_DIR}/%s" % self.relpath(path)

    def get_include_path(self, include_path):
        if include_path.startswith(self.db.directory) \
                or include_path == self.db.directory[:-1]:
            return os.path.relpath(include_path, self.directory[:-1])
        return include_path

    def name_as_target(self, path):
        relative_path = self.relpath(path).rsplit('/', 1)[-1]
        basename = os.path.basename(relative_path)
        name = basename.split('.', 1)[0]
        name = re.sub(self.disallowed_characters, "_", name)
        name = name if not name.startswith('lib') else name[3:]
        return self.use_target_name(name, path)

    def use_target_name(self, name, path):
        if path is None:
            path = self.resolve(name, self.directory)
        used_path = self.used_names.get(name)
        if used_path == path:
            return name
        if used_path is not None:
            index = 2
            while True:
                candidate = '{}_{}'.format(name, index)
                if candidate not in self.used_names:
                    name = candidate
                    break
                index = index + 1
        self.used_names[name] = path
        return name

    def name_by_common_prefix(self, files):
        prefix = os.path.commonprefix(files)
        name = os.path.basename(prefix.rstrip("-_."))
        name = re.sub(self.disallowed_characters, "", name)
        return name

    def get_cmake_generator(self, direcoty):
        if self.single_file or self.directory == direcoty:
            return self
        name = "%s-%s" % (self.name, self.relpath(direcoty))
        generators = self.__class__.generators
        generator = generators.get(name)
        if generator is None:
            generator = CmakeGenerator(self.db, name, direcoty)
            self.output_subdirectory(direcoty)
            generators[name] = generator
        return generators[name]

    def output_subdirectory(self, directory):
        info("Project in %s add subdirectory %s"
             % (self.db.relpath(self.directory), self.db.relpath(directory)))
        self.output.write("add_subdirectory(%s)\n" % self.relpath(directory))

    def output_linked_target(self, cmd_id, files, target, libtype):
        name = self.name_as_target(target)
        debug("%s %s linked by cmd #%s from %s"
              % (libtype, self.relpath(target), cmd_id,
                 ' '.join([self.relpath(f) for f in files])))
        config = {k: v for (k, v) in self.db.command[cmd_id].items()}
        source_files, config = self.migrate_sub_compilations(config, files, target, name)
        debug("Target %s output linked %s %s for %s"
              % (name, libtype, self.relpath(target),
                 ' '.join([self.relpath(f) for f in source_files])))
        self.output_cmake_target(name, config, source_files, target, libtype)

    def migrate_sub_compilations(self, config, files, target, name):
        source_files = set()
        referenced_libs = set()
        compilations = {}
        for f in files:
            if f in self.db.linkings:
                refer = self.refer_linked_target(f)
                info('%s refer linked target %s'
                     % (self.relpath(target), self.relpath(refer or f)))
                if refer:
                    if refer.startswith('${CMAKE'):
                        config['include_binary_dir'] = True
                    referenced_libs.add(refer)
                else:
                    source_files.add(f)
                continue
            if f not in self.db.objects:
                if f.rsplit('.', 1)[-1] not in ('c', 'cpp', 'cc', 'java'):
                    info('%s referenced %s not in linked objects as bellow\n\t%s'
                         % (self.relpath(target), f,
                            '\n\t'.join(self.db.linkings.keys())))
                source_files.add(f)
                continue
            for source, com_id in self.db.objects[f].items():
                compilations.setdefault(com_id, {})[source] = f
        if referenced_libs:
            config.setdefault('referenced_libs', set()).update(referenced_libs)
        if len(compilations) > 1:
            warn("Target %s is created by multiple commands: %s"
                 % (self.db.relpath(target),
                    ' '.join(["#%s" % cmd for cmd in compilations])))
        for cmd_id, source_product in compilations.items():
            for k, v in self.db.command[cmd_id].items():
                value = config.get(k, v)
                if type(value) in (set, tuple, frozenset):
                    value = list(value)
                    config[k] = value
                if isinstance(value, list):
                    for part in v:
                        if part not in value:
                            value.append(part)
                elif v and not config.get(k):
                    config[k] = v
            for source, product in source_product.items():
                self.reduce_target(source, cmd_id, product, name)
                if source in self.db.linkings:
                    command_sources = self.db.linkings[source]
                    for cid in command_sources.keys():
                        if self.db.command[cid]['linkage'] == 'SOURCE':
                            config['include_binary_dir'] = True
                source_files.add(source)
        return source_files, config

    def refer_linked_target(self, f):
        command_sources = self.db.linkings[f]
        if not command_sources:
            return None
        if len(command_sources) > 1:
            warn("find multiple command creating the same target: %s" % f)
        cmd_id = command_sources.keys()[0]
        linkage = self.db.command[cmd_id].get('linkage')
        if linkage in ('STATIC', 'SHARED'):
            return self.name_as_target(f)
        elif linkage == 'SOURCE':
            refer = self.cmake_resolve_binary(f)
            debug("refer generated source %s" % refer)
            return refer
        return None

    def reduce_target(self, source, cmd_id, product, name):
        target_sources = self.db.targets.get(cmd_id, {})
        sources = target_sources.get(product, set())
        if source in sources:
            sources.remove(source)
            if not sources:
                target_sources.pop(product)
                debug("pop %s from targets of cmd #%s"
                      % (self.relpath(product), cmd_id))
            debug("Target %s use source %-20s instead of %s"
                  % (name, self.relpath(source), self.relpath(product)))
        else:
            warn("file %s not in source list of target %s\n\t%s\n%s" % (
                source, product, '\n\t'.join(sources),
                '\n'.join(["%s: %s" % x for x in cmd_id])))

    def write_command(self, command, options, name, parts, single_line=None):
        if single_line is None:
            single_line = len(' '.join(parts)) < 40
        delimiter = ' ' if single_line else '\n    '
        tail = '' if single_line else '\n'
        content = delimiter + (delimiter.join(parts)) + tail
        self.output.write('%s(%s %s%s)\n\n' % (command, name, options, content))

    def output_includes(self, options, name, parts): 
        if not parts: return
        info("Target %s includes %s\n\t%s"
             % (name, options, '\n\t'.join(parts)))
        if self.directory:
            parts = [self.get_include_path(include) for include in parts]
        self.write_command('target_include_directories', options, name, parts)

    def output_compile_args(self, arg_type, name, config): 
        parts = config.get(arg_type, ())
        info("Target %s output compile %-11s: %s"
             % (name, arg_type, ' '.join(parts)))
        if not parts: return
        self.write_command('target_compile_' + arg_type, 'PRIVATE', name, parts)

    def write(self):
        name = self.name

        for (target, command_source) in self.db.linkings.items():
            commands = command_source.keys()
            if len(commands) > 1:
                warn("target %s created by multiple command:\n%s" % (
                    target, commands))
            for cmd_id, files in command_source.items():
                command = self.db.command[cmd_id]
                directory = command['cwd']
                linkage = command.get('linkage', 'OBJECT')
                info("Process %s target %s" % (linkage, self.relpath(target)))
                generator = self.get_cmake_generator(directory)
                if linkage == 'SOURCE':
                    generator.output_custom_command(target, cmd_id, files)
                else:
                    generator.output_linked_target(cmd_id, files, target, linkage)

        for cmd_id, target_sources in self.db.targets.items():
            files = set()
            for target, sources in target_sources.items():
                if target in self.db.linkings: continue
                for f in sources:
                    cmd = self.db.sources.get(f, {}).get(target, cmd_id)
                    if cmd != cmd_id:
                        warn("target %s gen by command %s and %s" % (target, cmd, cmd_id))
                    files.add(f)
            if files:
                self.output_library(cmd_id, files)

    def output_custom_command(self, target, cmd_id, sources):
        config = self.db.command[cmd_id]
        info("cmd #%s output custom target %s generated from %s"
             % (cmd_id, self.relpath(target), ' '.join([self.relpath(f) for f in sources])))
        compiler = config.get('compiler')
        options = config.get('options', ())
        self.output.write("add_custom_command(OUTPUT %s\n\tCOMMAND %s\n\t%s\n\t%s\n\t%s\n)\n"
                          % (self.relpath(target), compiler, ' '.join(options),
                             ' '.join([self.cmake_resolve_source(f) for f in sources]),
                             self.custom_target_output_args(compiler, target)))


    def output_library(self, cmd_id, files, libtype=None):
        name = self.name_by_common_prefix(files)
        if not libtype:
            libtype = 'OBJECT'
        config = self.db.command[cmd_id]
        directory = config['cwd']
        generator = self.get_cmake_generator(directory)
        info("cmd #%s output %s library target %s with %s"
             % (cmd_id, libtype or 'unlinked', name,
                ' '.join([self.relpath(f) for f in files])))
        generator.output_cmake_target(name, config, files, None, libtype)

    def output_cmake_target(self, name, config, files, target, libtype):
        if not files or not name: return
        files = set([self.relpath(f) for f in files])
        missing_depends = config.get('missing_depends', [])
        if missing_depends:
            warn("Target %s depend on missing files:\n\t%s"
                 % (name, '\n\t'.join(missing_depends)))
            missing_depends = [self.relpath(f) for f in missing_depends]
            files.update(missing_depends)
            config['include_binary_dir'] =True
        name = self.use_target_name(name, target)
        info("Target %s output cmake %-13s: %s" % (name, libtype, ' '.join(files)))
        if not libtype or libtype == 'EXECUTABLE':
            self.write_command('add_executable', '', name, files)
        else:
            self.write_command('add_library', libtype, name, files)
        self.output_target_config(name, config)

    def output_target_config(self, name, config):
        self.output_compile_args('options', name, config)
        self.output_compile_args('definitions', name, config)
        if config.get('include_binary_dir'):
            self.output_includes('PRIVATE', name, ['${CMAKE_CURRENT_BINARY_DIR}'])
        self.output_includes('PRIVATE', name, config.get('includes'))
        self.output_includes('SYSTEM PRIVATE', name, config.get('system_includes'))
        self.output_includes('BEFORE PRIVATE', name, config.get('iquote_includes'))
        self.output_target_libs(name, config)

    def output_target_libs(self, name, config):
        libs = config.get('referenced_libs', set()).copy()
        if libs:
            debug("Target %s using referenced libs %s" % (name, ' '.join(libs)))
        libs.update(config.get('libs', set()))
        if libs:
            self.write_command('target_link_libraries', 'PRIVATE', name, libs)


def get_default_name(compilation_database):
    filename = os.path.realpath(compilation_database.name)
    if not os.path.isfile(filename):
        return 'autogenerated'
    directory = os.path.dirname(filename)
    try:
        output = subprocess.Popen(
            ['git', 'rev-parse', '--show-toplevel'],
            cwd=directory, stdout=subprocess.PIPE).communicate()[0]
        output = output.strip()
        return os.path.basename(output)
    except Exception:
        return 'autogenerated'


def main():
    parser = argparse.ArgumentParser(description="""
        Convert a compile_commands.json file to a CMakeLists.txt file.
    """)

    infile = 'compile_commands.json' if os.isatty(sys.stdin.fileno()) else '-'
    parser.add_argument(
        'infile', nargs='?', type=argparse.FileType('r'), default=infile,
        help="""
path of the compilation database (default: compile_commands.json or stdin)
        """
    )
    outfile = 'CMakeLists.txt' if os.isatty(sys.stdout.fileno()) else '-'
    parser.add_argument(
        'outfile', nargs='?', type=argparse.FileType('w'), default=outfile,
        help="""
path of the CMake file (default: CMakeLists.txt or stdout)
        """
    )

    parser.add_argument(
        '-n', '--name', help="""
name of the CMake project (default: taken from Git root, or 'autogenerated')
        """
    )
    parser.add_argument(
        '-d', '--debug', action='store_true', default=False, help="""
enable debug log output
        """
    )
    parser.add_argument(
        '-m', '--multiple-file', action='store_true', default=False, help="""
split CMakeLists.txt into multiple files in subdirectories,
according to the working directory when executing each build command.
        """
    )
    args = parser.parse_args()
    if args.debug:
        logger.setLevel(logging.DEBUG)

    if args.name is None:
        args.name = get_default_name(args.infile)

    db = CompilationDatabase(args.infile, args.outfile)
    db.read()
    single = not args.multiple_file
    generator = CmakeGenerator(db, args.name, db.directory, single)
    generator.write()


if __name__ == '__main__':
    main()
