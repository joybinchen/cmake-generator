#!/usr/bin/env python3
import argparse
import json
import os.path
import re
import shlex
import subprocess
import sys
import logging
import diff_match_patch

diff = diff_match_patch.diff_match_patch().diff_main

if not hasattr(__builtins__, 'basestring'):
    basestring = str

# FORMAT = '%(asctime)-15s %(levelname)-8s %(module)s %(message)s'
FORMAT = '%(levelname)-8s %(lineno)5d %(message)s'
logging.basicConfig(format=FORMAT)
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
info = logger.info
debug = logger.debug
warn = logger.warning
error = logger.error

DISALLOWED_CHARACTERS = re.compile("[^A-Za-z0-9_.+\\-]")
CUSTOM_TARGET_OUTPUT_CONFIG = {
    'glib-genmarshal': '--output ',
    'dbus-binding-tool': '--output=',
    'moc': '-o ',
    'msgfmt': '-o ',
}


def freeze(obj):
    if isinstance(obj, dict):
        return freeze(tuple([freeze(x) for x in sorted(obj.items(), key=lambda i: i[0])]))
    if isinstance(obj, list):
        return tuple([freeze(x) for x in obj])
    if isinstance(obj, set):
        return frozenset({freeze(x) for x in obj})
    if isinstance(obj, tuple):
        return tuple([freeze(x) for x in obj])
    return obj


def get_diff_pattern(text1, text2):
    diff_result = diff(text1, text2)
    pattern = []
    lhs = rhs = ''
    fields = []
    for diff_type, diff_part in diff_result:
        if diff_type < 0:
            lhs += diff_part
        elif diff_type > 0:
            rhs += diff_part
        else:
            if lhs or rhs:
                if fields and len(pattern[-1]) <= 3:
                    delimiter = pattern.pop(-1)
                    field = fields.pop(-1)
                    fields.append((
                        field[0] + delimiter + lhs,
                        field[1] + delimiter + rhs,
                    ))
                else:
                    pattern.append('%%(%d)s' % len(fields))
                    fields.append((lhs, rhs))
                lhs = rhs = ''
            pattern.append(diff_part)
    #debug('Diff result %s for %s %s: %s' % (pattern, text1, text2, fields))
    return ''.join(pattern), fields


class PathUtils(object):
    def __init__(self, cwd):
        if not cwd.endswith('/'):
            cwd = cwd + '/'
        self.directory = cwd
        self.db = self

    def relpath(self, path):
        if self.directory and (path.startswith(self.db.directory)
                               or path == self.db.directory):
            return os.path.relpath(path, self.directory)
        return path

    def resolve(self, path, cwd=None):
        if cwd is None:
            cwd = self.directory
        if not os.path.isabs(path):
            path = os.path.join(cwd, path)
        return os.path.normcase(os.path.normpath(path))


class CompilationDatabase(PathUtils):
    def __init__(self, infile, outfile):
        super(self.__class__, self).__init__('')
        self.targets = {}
        self.sources = {}
        self.objects = {}
        self.linkings = {}
        self.installs = {}
        self.install_command = []
        self.command = []
        self.input = infile
        filename = os.path.realpath(infile.name)
        if os.path.isfile(filename):
            self.cmake_filename = filename
            self.directory = os.path.dirname(filename) + '/'
        else:
            self.cmake_filename = 'autogenerated'
            self.directory = ''

    def parse_command(self, command, cwd, file_):
        if isinstance(command, basestring):
            command = shlex.split(command)
        words = iter(command)
        compiler = os.path.basename(next(words))  # remove the initial 'cc' / 'c++'
        if compiler.startswith('python'):
            compiler = os.path.basename(next(words))

        config = {}
        options = []
        definitions = []
        includes = []
        system_includes = set()
        iquote_includes = set()
        libs = set()
        linkage = 'EXECUTABLE'
        target = ''
        missing_depends = []

        if compiler == 'ccache':
            compiler = 'clang'
        if compiler == 'msgfmt':
            linkage = 'LOCALE'
        if compiler == 'git':
            for word in words:
                if word == '>':
                    linkage = 'SOURCE'
                    target = next(words)
                elif word.startswith('-'):
                    options.append(word)
                else:
                    options.append(word)
        elif compiler == 'moc':
            for word in words:
                if word == '-o':
                    linkage = 'SOURCE'
                    target = next(words)
                elif word.startswith('-'):
                    if word == '--include':
                        options.append('%s %s' % (word, next(words)))
                    else:
                        options.append(word)

        elif compiler == 'install':
            for word in words:
                if word.startswith('-'):
                    if word == '-c':
                        options.append(word)
                    if word == '-m':
                        options.append("%s %s" % (word, next(words)))
                    else:
                        options.append(word)
                elif word != file_:
                    linkage = 'INSTALL'
                    target, destination = self.resolve_destination(word, cwd, file_)
                    config['destination'] = destination

        elif compiler == 'qmake':
            for word in words:
                if word.startswith('-'):
                    if word == '-install':
                        options.append("%s %s" %(word, next(words)))
                    else:
                        options.append(word)
                elif word != file_:
                    linkage = 'INSTALL'
                    target, destination = self.resolve_destination(word, cwd, file_)
                    config['destination'] = destination

        elif compiler == 'lrelease':
            for word in words:
                if word == '-qm':
                    linkage = 'LOCALE'
                    target = next(words)
                elif word.startswith('-'):
                    options.append(word)

        elif compiler == 'glib-genmarshal':
            for word in words:
                if word == '--output':
                    linkage = 'SOURCE'
                    target = next(words)
                elif word.startswith('-'):
                    options.append(word)

        elif compiler == 'dbus-binding-tool':
            for word in words:
                if word.startswith('--output='):
                    linkage = 'SOURCE'
                    target = word[len('--output='):]
                elif word.startswith('-'):
                    options.append(word)

        elif compiler.endswith("ar"):
            for word in words:
                if not target:
                    if word.startswith('-'):
                        if 'c' in word:
                            linkage = 'STATIC'
                            target = next(words)
                    elif 'c' in word:
                        linkage = 'STATIC'
                        target = next(words)
                    else:
                        options.append(word)

        for word in words:
            if word == '-o':
                target = next(words)
            elif word.startswith('-I'):
                include = word[2:]
                includes.append(self.resolve(include, cwd))
            elif word == '-isystem':
                include = next(words)
                include = self.resolve(include, cwd)
                if include not in includes:
                    includes.append(include)
                system_includes.add(include)
            elif word == '-iquote':
                include = next(words)
                include = self.resolve(include)
                if include not in includes:
                    includes.append(include)
                iquote_includes.add(include)
            elif word.startswith('-D'):
                define = word[2:]
                if define.find('=') > 0:
                    name, value = define.split('=', 1)
                    if value:
                        define = '%s="%s"' % (name, value)
                definitions.append(define)
            elif word == '-c':
                linkage = 'OBJECT'
            elif word in ['-arch', '-include', '-x']:
                options.append('%s %s' % (word, next(words)))
            elif word in ['-MM', '-MQ', '-M', '-MP', '-MG']:
                continue
            elif word in ['-MT', '-MF', '-MQ', '-MD', '-MMD', '-ccc-gcc-name']:
                next(words)
            elif word.startswith('-L'):
                libs.add(word if len(word) > 2 else ('-L'+next(words)))
            elif word.startswith('-l'):
                libs.add(word[2:] or next(words))
            elif word in ['-g', '-O1', '-O2', '-O3']:
                continue
            elif word == '-O':
                next(words)
            elif word.startswith('-m'):
                options.append(word)
                libs.add(word)
            elif word == '-shared':
                options.append(word)
                linkage = 'SHARED'
            elif word.startswith('-'):
                options.append(word)

        config.update({
            'cwd': cwd,
            'compiler': compiler,
            'linkage': linkage,
        })
        if libs:
            config['libs'] = freeze(libs)
        if options:
            config['options'] = freeze(options)
        if definitions:
            config['definitions'] = freeze(definitions)
        if includes:
            config['includes'] = freeze(includes)
        if system_includes:
            config['system_includes'] = freeze(system_includes)
        if iquote_includes:
            config['iquote_includes'] = freeze(iquote_includes)
        if linkage == 'OBJECT':
            missing_depends = self.find_dependencies(compiler, file_, config)
            if missing_depends:
                info("OBJECT %-25s depends on missing %s"
                     % (self.relpath(target),
                        ' '.join([self.relpath(f) for f in missing_depends])))
        return config, target, missing_depends

    def resolve_destination(self, path, cwd, file_):
        target = self.resolve(path, cwd)
        if os.path.isdir(target):
            destination = target
            target = os.path.join(target, os.path.basename(file_))
        else:
            if os.path.basename(target) == os.path.basename(file_):
                destination = os.path.dirname(target)
            else:
                destination = target
        return target, destination

    def find_dependencies(self, compiler, file_, config):
        cwd = config['cwd']
        if not cwd.endswith('/'):
            cwd += '/'
        if not os.path.isabs(file_):
            file_ = cwd + file_
        if not os.path.exists(file_):
            return [file_]

        dep_command = [compiler, '-MM', '-MG', file_.encode('utf-8')]
        dep_command.extend(['-D'+p for p in config.get('definitions', ())])
        dep_command.extend(['-I'+p for p in config.get('includes', ())])
        for p in config.get('system_includes', ()):
            dep_command.extend(['-isystem', p])
        for p in config.get('iquote_includes', ()):
            dep_command.extend(['-iquote', p])
        if '-fPIC' in config.get('options', []):
            dep_command.append('-fPIC')
        #debug('check dependencies on %s with commond: %s' %(cwd, ' '.join(dep_command)))
        process = subprocess.Popen(dep_command, cwd=cwd, stdout=subprocess.PIPE)
        output = process.communicate()[0].strip().decode('utf-8')
        if not output:
            return []

        depends = output.split(': ', 1)[1].replace('\\\n  ', '').split(' ')
        depend_list = [f if os.path.isabs(f) else cwd + f for f in depends]
        #debug('Files relative to %s\n\t%s' % (self.directory, '\n\t'.join(
        #      filter(lambda x: not x.startswith('/usr/'), depend_list))))
        depend_list = [os.path.relpath(f, self.directory) for f in depend_list]
        local_depends = filter(lambda x: not x.startswith('../'), depend_list)
        missing_depends = filter(lambda x: not os.path.exists(x), local_depends)
        return [self.directory + f for f in missing_depends]

    def read(self, input=None):
        if input is None:
            input = self.input
        database = json.load(input)
        cmd_dict = {}
        install_cmd_dict = {}
        for entry in database:
            self.read_command(entry, cmd_dict, install_cmd_dict)

    def read_command(self, entry, cmd_dict, install_cmd_dict):
        cwd = entry.get('directory', self.directory)
        file_ = self.resolve(entry['file'], cwd)
        arguments = shlex.split(entry.get('command', ''))
        arguments = entry.get('arguments', arguments)
        cmd, target, missing_depends = self.parse_command(arguments, cwd, file_)
        if not cmd:
            return cmd

        target = self.resolve(target, cwd)
        linkage = cmd.get('linkage')
        if linkage == 'INSTALL':
            self.update_install_index(target, cmd, file_, install_cmd_dict)
            return cmd

        cmd_id = self.update_command_index(cmd, cmd_dict, self.command, debug)
        self.update_target_index(target, cmd_id, file_, linkage)
        for depend in missing_depends:
            debug('Update missing_depends for cmd #%s: %s' % (cmd_id, depend))
            self.command[cmd_id].setdefault('missing_depends', set()).add(depend)
        return cmd

    @staticmethod
    def update_command_index(cmd, cmd_dict, cmd_list, log=None):
        command = freeze(cmd)
        cmd_id = cmd_dict.get(command)
        if cmd_id is None:
            cmd_id = len(cmd_list)
            cmd_dict[command] = cmd_id
            cmd_list.append(cmd)
            if log:
                log('New cmd #%s: %s'
                    % (cmd_id, '\n'.join(["%-10s %s" % x for x in command])))
        return cmd_id

    def update_install_index(self, target, cmd, file_, cmd_dict):
        cmd_id = self.update_command_index(cmd, cmd_dict, self.install_command)
        debug("Install cmd #%s install %-27s => %s"
              % (cmd_id, self.relpath(file_), self.relpath(target)))
        self.installs.setdefault(cmd_id, {})[target] = file_

    def update_target_index(self, target, cmd_id, file_, linkage):
        debug("entry %-35s cmd #%s => %-10s %s"
              % (self.relpath(file_), cmd_id, linkage, self.relpath(target)))
        self.sources.setdefault(file_, {})[target] = cmd_id
        self.objects.setdefault(target, {})[file_] = cmd_id
        self.targets.setdefault(cmd_id, {}).setdefault(target, set()).add(file_)
        if linkage not in ('OBJECT', 'LOCALE', None):
            self.update_linking_index(target, cmd_id, file_)

    def update_linking_index(self, target, cmd_id, file_):
        debug("Add linked target %s from %s"
              % (self.relpath(target), self.relpath(file_)))
        self.linkings.setdefault(target, {}).setdefault(cmd_id, set()).add(file_)


class CmakeConverter(PathUtils):

    generators = {}

    def __init__(self, database, name, cwd, single_file=False):
        super(self.__class__, self).__init__(cwd)
        self.db = database
        self.name = name
        self.single_file = single_file
        self.common_configs = {}

    def simplify_command_common_args(self, arg_name):
        common_values = None
        for values in [cmd.get(arg_name) for cmd in self.db.command]:
            if values:
                if common_values is None:
                    common_values = list(values)
                    continue
                for v in common_values:
                    if v not in values:
                        common_values.remove(v)
        if not common_values:
            return None
        self.common_configs[arg_name] = common_values
        for command in self.db.command:
            values = command.get(arg_name)
            if values is None:
                continue
            new_values = filter(lambda x: x not in common_values, values)
            command[arg_name] = freeze(tuple(new_values))
        return common_values

    def migrate_install_commands(self):
        groups = {}
        installs = list(filter(lambda x: len(x[1]) == 1, self.db.installs.items()))
        migrated_commands = {}
        for cmd_id, target_files in installs:
            self.db.installs.pop(cmd_id)
            command = self.db.install_command[cmd_id].copy()
            destination = command.pop('destination')
            target, file_ = next(iter(target_files.items()))
            freezed = freeze(command)
            new_cmd_id = migrated_commands.get(freezed)
            if new_cmd_id is None:
                new_cmd_id = len(self.db.install_command)
                migrated_commands[freezed] = new_cmd_id
                self.db.install_command.append(dict(command))
            dest_groups = groups.setdefault(freezed, {})
            self.migrate_command(target, file_, dest_groups)
            self.db.install_command[cmd_id] = None
            debug('Install cmd #%d migrated into cmd #%d' % (cmd_id, new_cmd_id))

        for command, dest_groups in groups.items():
            cmd_id = migrated_commands[command]
            self.db.installs[cmd_id] = dest_groups

    def migrate_command(self, target, source, groups):
        if not groups:
            info('Initialize empty group with source & target\n\t%s => %s'
                 % (target, source))
            groups[(target, '')] = [(source, target), ]
            return True

        for (dest, src_pattern), file_targets in groups.items():
            if src_pattern:
                matcher = re.compile(src_pattern % {'0': '(.*)'})
                matched = matcher.match(source)
                if matched:
                    match_groups = matched.groups()
                    convert_dict = dict([(str(i), g) for i, g in
                                         zip(range(0, len(match_groups)), match_groups)])
                    converted_target = dest % convert_dict
                    if converted_target == target:
                        file_targets.append((source, target))
                        info (('Existed pattern\t%s\t%s\n\t' % (src_pattern, dest)) +
                              ('matches source and target\t%s\t%s\n' % (source, target)))
                        return True

        for (dest, src_pattern), file_targets in groups.items():
            prev_pattern = src_pattern or file_targets[0][0]
            file_pattern, file_fields = get_diff_pattern(
                prev_pattern, source)
            if len(file_fields) != 1: continue
            dest_pattern, dest_fields = get_diff_pattern(dest, target)
            if not dest_pattern: continue
            debug('Found pattern %s with fields %s for\n\t%s\n\t%s\nsrc_pattern=\t%s\nfile_pattern=\t%s'
                  % (dest_pattern, dest_fields, dest, target, src_pattern, file_pattern))

            field_dict = {}
            pattern_ok = True
            for field in dest_fields:
                if field not in file_fields:
                    pattern_ok = False
                    break
                field_dict[str(file_fields.index(field))] = field[1]
            if not pattern_ok: continue

            info('migrating under %s\t%s\ngot\t%s\n\t%s\nfor\t%s\n\t%s\nand\t%s'
                 % (prev_pattern, field_dict,
                    dest_pattern, target,
                    file_pattern, source,
                    '\n\t'.join(["%s <- %s" % (t, self.relpath(f))
                                 for f, t in file_targets[:3]])))
            file_targets.append((source, target))
            if src_pattern != file_pattern:
                if src_pattern:
                    matcher = re.compile(file_pattern % {'0': '(.*)'})
                    for file_, target in file_targets:
                        if not matcher.match(file_):
                            return True
                    info('migrate_command when %s\n\treplace\t%s\n\t ===>\t%s\ntargets:\n\t%s'
                         % ((source, target),
                            (dest, src_pattern),
                            (dest_pattern, file_pattern),
                            '\n\t'.join(["%s\t%s" % x for x in file_targets])))
                groups.pop((dest, src_pattern))
                groups[(dest_pattern, file_pattern)] = file_targets
            return True
        info('No matching pattern %s in groups' % target)
        groups[(target, '')] = [(source, target), ]
        return True

    def convert(self):
        root_generator = self.get_root_generator()
        for arg_name in ('includes', 'system_includes', 'iquote_includes',
                         'options', 'definitions'):
            values = self.simplify_command_common_args(arg_name)
            if values:
                root_generator.output_project_common_args(arg_name, values)
        self.migrate_install_commands()
        self.write()

    def write(self):
        for (target, command_source) in self.db.linkings.items():
            commands = command_source.keys()
            if len(commands) > 1:
                warn("target %s created by multiple command:\n%s" % (
                    target, commands))
            for cmd_id, files in command_source.items():
                command = self.db.command[cmd_id]
                directory = command['cwd']
                linkage = command.get('linkage', 'OBJECT')
                info("Process %s target %s" % (linkage, self.relpath(target)))
                generator = self.get_cmake_generator(directory)
                if linkage == 'SOURCE':
                    generator.output_custom_command(target, cmd_id, files)
                else:
                    generator.output_linked_target(cmd_id, files, target, linkage)

        for cmd_id, target_sources in self.db.targets.items():
            command = self.db.command[cmd_id]
            linkage = command.get('linkage', 'OBJECT')
            if linkage == 'LOCALE':
                self.output_locales(cmd_id, command, target_sources)
                continue
            files = set()
            for target, source in target_sources.items():
                if target in self.db.linkings: continue
                for f in source:
                    cmd = self.db.sources.get(f, {}).get(target, cmd_id)
                    if cmd != cmd_id:
                        warn("target %s gen by command %s and %s" % (target, cmd, cmd_id))
                    files.add(f)
            if files:
                self.output_library(cmd_id, command, tuple(files), linkage)

        for cmd_id, target_sources in self.db.installs.items():
            files = set()
            command = self.db.install_command[cmd_id]
            for target, source in target_sources.items():
                if type(target) is basestring:
                    files.add(source)
                    continue
                # target is tuple
                if target[1]:
                    self.output_migrated_install(cmd_id, target, source)
                    continue
                if len(source) != 1:
                    warn("Install target %s fail to migrate by install cmd #%s" % (target, cmd_id))
                for f in source:
                    command['destination'] = f[0]
                    files.add(f[1])
            if files:
                self.output_install(cmd_id, command, tuple(files))

    def output_migrated_install(self, cmd_id, patterns, files):
        dest_pattern, file_pattern = patterns
        if not file_pattern:
            self.output_install(cmd_id, self.db.install_command[cmd_id], files)
        matcher = re.compile(file_pattern % {'0': '(.*)'})
        matched = []
        for file_, target in files:
            match = matcher.match(file_)
            if match.groups():
                matched.append(match.groups()[0])
            else:
                debug('Fail to match %s in %s' % (file_pattern, file_))
        command = self.db.install_command[cmd_id]
        generator = self.get_cmake_generator(command['cwd'])
        generator.output_migrated_install(command, dest_pattern, file_pattern, matched)

    def get_root_generator(self):
        return self.get_cmake_generator(self.db.directory)

    def get_cmake_generator(self, directory):
        if self.single_file:
            directory = self.directory
        if directory == self.directory:
            name = self.name
        else:
            name = "%s-%s" % (self.name, self.relpath(directory))
        generators = self.__class__.generators
        generator = generators.get(name)
        if generator is None:
            generator = CmakeGenerator(self.db, name, directory, self.single_file)
            generators[name] = generator
            root_generator = self.get_root_generator()
            if root_generator != generator:
                root_generator.output_subdirectory(directory)
        return generators[name]

    def output_install(self, cmd_id, config, files):
        name = self.name_by_common_prefix(files)
        directory = config['cwd']
        generator = self.get_cmake_generator(directory)
        info("Target %s installed by cmd #%s to %s"
             % (name, cmd_id, ' '.join([self.relpath(f) for f in files])))
        generator.output_cmake_install(name, config, files)

    def output_locales(self, cmd_id, command, target_sources):
        generator = self.get_cmake_generator(command['cwd'])
        groups = {}
        for target, sources in target_sources.items():
            for source in sources:
                self.migrate_command(target, source, groups)
        for (dest_pattern, src_pattern), target_sources in groups.items():
            info("cmd #%s output locale target\n\t%s"
                 % (cmd_id, '\n\t'.join(
                    ['%s <- %s' % (self.relpath(t), self.relpath(s))
                     for t, s in target_sources])))
            generator.output_locales(
                cmd_id, command, dest_pattern, src_pattern, target_sources)

    def output_library(self, cmd_id, command, files, linkage):
        generator = self.get_cmake_generator(command['cwd'])
        name = self.name_by_common_prefix(files)
        info("cmd #%s output %s library target %s with %s"
             % (cmd_id, linkage or 'unlinked', name,
                ' '.join([self.relpath(f) for f in files])))
        generator.output_cmake_target(name, command, files, None, linkage)

    def name_by_common_prefix(self, files):
        prefix = os.path.commonprefix(files)
        name = os.path.basename(prefix.rstrip("-_."))
        name = re.sub(DISALLOWED_CHARACTERS, "", name)
        return name


class CmakeGenerator(PathUtils):
    used_names = {"": ""}

    def __init__(self, database, name, cwd, single_file=False):
        super(self.__class__, self).__init__(cwd)
        self.db = database
        self.name = name
        self.output = open(os.path.join(cwd, 'CMakeLists.txt'), 'w')
        self.single_file = single_file
        self.output.write('cmake_minimum_required(VERSION 2.8.8)\n')
        info("write project %s in directory \t%s" % (name, self.directory))
        self.output.write('project({} LANGUAGES C CXX)\n\n'.format(name))

    def output_project_common_args(self, arg_name, values):
        if not values:
            return
        if arg_name.endswith('includes'):
            if arg_name == 'includes':
                self.write_command('include_directories', 'AFTER', '', values)
            elif arg_name == 'system_includes':
                self.write_command('include_directories', 'AFTER', 'SYSTEM', values)
            elif arg_name == 'iquote_includes':
                self.write_command('include_directories', 'AFTER', '', values)
        elif arg_name in ('options', 'definitions'):
            self.write_command('add_compile_' + arg_name, '', '', values)

    def write(self):
        self.output.write('cmake_minimum_required(VERSION 2.8.8)\n')
        info("write project %s in directory \t%s" % (self.name, self.directory))
        self.output.write('project({} LANGUAGES C CXX)\n\n'.format(self.name))

    def custom_target_output_args(self, compiler, target):
        prefix = CUSTOM_TARGET_OUTPUT_CONFIG.get(compiler, ' ')
        return prefix + self.cmake_resolve_binary(target)

    def cmake_resolve_source(self, path):
        return "${CMAKE_CURRENT_SOURCE_DIR}/%s" % self.relpath(path)

    def cmake_resolve_binary(self, path):
        return "${CMAKE_CURRENT_BINARY_DIR}/%s" % self.relpath(path)

    def get_include_path(self, include_path):
        if include_path.startswith(self.db.directory) \
                or include_path == self.db.directory[:-1]:
            return os.path.relpath(include_path, self.directory[:-1])
        return include_path

    def name_as_target(self, path):
        relative_path = self.relpath(path).rsplit('/', 1)[-1]
        basename = os.path.basename(relative_path)
        name = basename.rsplit('.', 1)[0]
        name = DISALLOWED_CHARACTERS.sub("_", name)
        name = name if not name.startswith('lib') else name[3:]
        return self.use_target_name(name, path)

    def use_target_name(self, name, path):
        if path is None:
            path = self.resolve(name, self.directory)
        used_path = self.used_names.get(name)
        if used_path == path:
            return name
        if used_path is not None:
            index = 2
            while True:
                candidate = '{}_{}'.format(name, index)
                if candidate not in self.used_names:
                    name = candidate
                    break
                index = index + 1
        self.used_names[name] = path
        return name

    def output_subdirectory(self, directory):
        info("Project in %s add subdirectory %s"
             % (self.db.relpath(self.directory), self.db.relpath(directory)))
        self.output.write("add_subdirectory(%s)\n" % self.relpath(directory))

    def output_linked_target(self, cmd_id, files, target, libtype):
        name = self.name_as_target(target)
        debug("%s %s linked by cmd #%s from %s"
              % (libtype, self.relpath(target), cmd_id,
                 ' '.join([self.relpath(f) for f in files])))
        config = {k: v for (k, v) in self.db.command[cmd_id].items()}
        source_files, config = self.migrate_sub_compilations(config, files, target, name)
        debug("Target %s output linked %s %s for %s"
              % (name, libtype, self.relpath(target),
                 ' '.join([self.relpath(f) for f in source_files])))
        self.output_cmake_target(name, config, source_files, target, libtype)

    def migrate_sub_compilations(self, config, files, target, name):
        source_files = set()
        referenced_libs = set()
        compilations = {}
        for f in files:
            if f in self.db.linkings:
                refer = self.refer_linked_target(f)
                info('%s refer linked target %s'
                     % (self.relpath(target), self.relpath(refer or f)))
                if refer:
                    if refer.startswith('${CMAKE'):
                        config['include_binary_dir'] = True
                    referenced_libs.add(refer)
                else:
                    source_files.add(f)
                continue
            if f not in self.db.objects:
                if f.rsplit('.', 1)[-1] not in ('c', 'cpp', 'cc', 'java', 'qm', 'qch', 'ts', 'po'):
                    info('%s referenced %s not in linked objects as bellow\n\t%s'
                         % (self.relpath(target), f,
                            '\n\t'.join(self.db.linkings.keys())))
                source_files.add(f)
                continue
            for source, cmd_id in self.db.objects[f].items():
                if self.db.command[cmd_id].get('linkage') != 'INSTALL':
                    compilations.setdefault(cmd_id, {})[source] = f
        if referenced_libs:
            config.setdefault('referenced_libs', set()).update(referenced_libs)
        if len(compilations) > 1:
            warn("Target %s is created by multiple commands: %s"
                 % (self.db.relpath(target),
                    ' '.join(["#%s" % cmd for cmd in compilations])))
        for cmd_id, source_product in compilations.items():
            for k, v in self.db.command[cmd_id].items():
                value = config.get(k, v)
                if type(value) in (set, tuple, frozenset):
                    value = list(value)
                    config[k] = value
                if isinstance(value, list):
                    for part in v:
                        if part not in value:
                            value.append(part)
                elif v and not config.get(k):
                    config[k] = v
            for source, product in source_product.items():
                self.reduce_target(source, cmd_id, product, name)
                if source in self.db.linkings:
                    command_sources = self.db.linkings[source]
                    for cid in command_sources.keys():
                        if self.db.command[cid]['linkage'] == 'SOURCE':
                            config['include_binary_dir'] = True
                source_files.add(source)
        return source_files, config

    def refer_linked_target(self, f):
        command_sources = self.db.linkings[f]
        if not command_sources:
            return None
        if len(command_sources) > 1:
            warn("find multiple command creating the same target: %s" % f)
        cmd_id = next(iter(command_sources.keys()))
        linkage = self.db.command[cmd_id].get('linkage')
        if linkage in ('STATIC', 'SHARED'):
            return self.name_as_target(f)
        elif linkage == 'SOURCE':
            refer = self.cmake_resolve_binary(f)
            debug("refer generated source %s" % refer)
            return refer
        return None

    def reduce_target(self, source, cmd_id, product, name):
        target_sources = self.db.targets.get(cmd_id, {})
        sources = target_sources.get(product, set())
        if source in sources:
            sources.remove(source)
            if not sources:
                target_sources.pop(product)
                debug("pop %s from targets of cmd #%s"
                      % (self.relpath(product), cmd_id))
            debug("Target %s use source %-20s instead of %s"
                  % (name, self.relpath(source), self.relpath(product)))
        else:
            warn("file %s not in source list of target %s\n\t%s\n%s" % (
                source, product, '\n\t'.join(sources),
                '\n'.join(["%s: %s" % x for x in cmd_id])))

    def write_command(self, command, options, name, parts, single_line=None):
        if single_line is None:
            single_line = len(' '.join(parts)) < 40
        delimiter = ' ' if single_line else '\n    '
        tail = '' if single_line else '\n'
        if not single_line and len(' '.join(parts)) / len(parts) < 7:
            lines = []
            for i in range(0, (len(parts) // 10) + 1):
                lines.append('\t'.join(parts[i*10:(i*10)+9]))
            content = delimiter + (delimiter.join(lines)) + tail
        else:
            content = delimiter + (delimiter.join(parts)) + tail
        self.output.write('%s(%s %s%s)\n' % (command, name, options, content))

    def output_includes(self, options, name, parts): 
        if not parts:
            return
        parts = [self.get_include_path(include) for include in parts]
        info("Target %s includes %s %s" % (name, options, ' '.join(parts)))
        self.write_command('target_include_directories', options, name, parts)

    def output_compile_args(self, arg_type, name, config): 
        parts = config.get(arg_type, ())
        info("Target %s output compile %-11s: %s"
             % (name, arg_type, ' '.join(parts)))
        if not parts: return
        self.write_command('target_compile_' + arg_type, 'PRIVATE', name, parts)

    def output_custom_command(self, target, cmd_id, sources):
        config = self.db.command[cmd_id]
        info("cmd #%s output custom target %s generated from %s"
             % (cmd_id, self.relpath(target), ' '.join([self.relpath(f) for f in sources])))
        compiler = config.get('compiler')
        options = config.get('options', ())
        self.output.write("add_custom_command(OUTPUT %s\n\tCOMMAND %s\n\t%s\n\t%s\n\t%s\n)\n"
                          % (self.relpath(target), compiler, ' '.join(options),
                             self.cmake_resolve_source('${X}'),
                             self.custom_target_output_args(compiler, target)))

    def output_locales(self, cmd_id, config, dest_pattern, src_pattern, paths):
        if src_pattern:
            matcher = re.compile(src_pattern % {'0': '(.*)'})
            fields = [matcher.match(x[0]).groups()[0] for x in paths]
        else:
            fields = ["''"]
        info("Locales created by cmd #%s to %s" % (cmd_id, ' '.join(fields)))
        self.write_command('foreach', '', 'X', fields)
        compiler = config['compiler']
        options = config.get('options', [])
        self.output.write("add_custom_command(OUTPUT %s\n\tCOMMAND %s %s\n\t%s\n\t%s\n)\n"
                          % (self.relpath(dest_pattern % {'0': '${X}'}),
                             compiler, ' '.join(options),
                             self.cmake_resolve_source(src_pattern % {'0': '${X}'}),
                             self.custom_target_output_args(
                                 compiler, dest_pattern % {'0': '${X}'})))
        self.output.write('endforeach(X)\n\n')

    def output_migrated_install(self, command, dest_pattern, file_pattern, matched):
        self.write_command('foreach', '', 'X', matched)
        self.output.write('install(%s\t%s\n\tDESTINATION\t%s\n)\n'
                          % ('FILES', self.relpath(file_pattern % {'0': '${X}'}),
                             dest_pattern % {'0': '${X}'}))
        self.output.write('endforeach(X)\n\n')

    def output_cmake_install(self, name, config, files):
        install_groups = {}
        for f in files:
            source_commands = self.db.objects.get(f, None)
            if source_commands is None:
                warn('Could not find command to create install Target: ' + self.resolve(f))
                install_groups.setdefault(-1, set()).add(f)
                continue
            cmd_id = next(iter(source_commands.values()))
            install_groups.setdefault(cmd_id, set()).add(f)
        for cmd_id, file_set in iter(install_groups.items()):
            if cmd_id >= 0:
                command = self.db.command[cmd_id]
                linkage = command.get('linkage', 'OBJECT')
                install_type = 'PROGRAMS' if linkage == 'EXECUTABLE' else 'FILES'
            else:
                install_type = 'FILES'
            self.output.write('install(%s\n\t%s\n\tDESTINATION %s\n)\n'
                               % (install_type,
                                  ' '.join([self.relpath(f) for f in file_set]),
                                  config.get('destination', 'NO-DESTINATION')))

    def output_cmake_target(self, name, config, files, target, libtype):
        if not files or not name: return
        files = sorted([self.relpath(f) for f in files])
        missing_depends = config.get('missing_depends', [])
        if missing_depends:
            missing_depends = [self.relpath(f) for f in missing_depends]
            warn("Target %s depends on missing files: %s"
                 % (name, ' '.join(missing_depends)))
            files.extend(missing_depends)
            config['include_binary_dir'] =True
        name = self.use_target_name(name, target)
        info("Target %s output cmake %-13s: %s" % (name, libtype, ' '.join(files)))
        if not libtype or libtype == 'EXECUTABLE':
            self.write_command('add_executable', '', name, files)
        else:
            self.write_command('add_library', libtype, name, files)
        self.output_target_config(name, config)

    def output_target_config(self, name, config):
        self.output_compile_args('options', name, config)
        self.output_compile_args('definitions', name, config)
        if config.get('include_binary_dir'):
            self.output_includes('PRIVATE', name, ['${CMAKE_CURRENT_BINARY_DIR}'])
        self.output_includes('PRIVATE', name, config.get('includes'))
        self.output_includes('SYSTEM PRIVATE', name, config.get('system_includes'))
        self.output_includes('BEFORE PRIVATE', name, config.get('iquote_includes'))
        self.output_target_libs(name, config)

    def output_target_libs(self, name, config):
        libs = config.get('referenced_libs', set()).copy()
        if libs:
            debug("Target %s using referenced libs %s" % (name, ' '.join(libs)))
        libs.update(config.get('libs', set()))
        if libs:
            self.write_command('target_link_libraries', 'PRIVATE', name, libs)


def get_default_name(compilation_database):
    filename = os.path.realpath(compilation_database.name)
    if not os.path.isfile(filename):
        return 'autogenerated'
    directory = os.path.dirname(filename)
    try:
        output = subprocess.Popen(
            ['git', 'rev-parse', '--show-toplevel'],
            cwd=directory, stdout=subprocess.PIPE).communicate()[0]
        output = output.strip()
        return os.path.basename(output).decode('utf-8')
    except Exception:
        return 'autogenerated'


def main():
    parser = argparse.ArgumentParser(description="""
        Convert a compile_commands.json file to a CMakeLists.txt file.
    """)

    infile = 'compile_commands.json' if os.isatty(sys.stdin.fileno()) else '-'
    parser.add_argument(
        'infile', nargs='?', type=argparse.FileType('r'), default=infile,
        help="""
path of the compilation database (default: compile_commands.json or stdin)
        """
    )
    outfile = 'CMakeLists.txt' if os.isatty(sys.stdout.fileno()) else '-'
    parser.add_argument(
        '-o', '--outfile', type=argparse.FileType('w'), default=outfile,
        help="""
path of the CMake file (default: CMakeLists.txt or stdout)
        """
    )

    parser.add_argument(
        '-n', '--name', help="""
name of the CMake project (default: taken from Git root, or 'autogenerated')
        """
    )
    parser.add_argument(
        '-d', '--debug', action='store_true', default=False, help="""
enable debug log output
        """
    )
    parser.add_argument(
        '-m', '--multiple-file', action='store_true', default=False, help="""
split CMakeLists.txt into multiple files in subdirectories,
according to the working directory when executing each build command.
        """
    )
    parser.add_argument(
        '-e', '--extra-infile', action='store', default='extra_commands.json',
        help="""
path of extra compilation database to put you hand writen commands,
which may be difficult to get automatically captured using a ld logger.
(default: extra_commands.json)
        """
    )
    args = parser.parse_args()
    if args.debug:
        logger.setLevel(logging.DEBUG)

    if args.name is None:
        args.name = get_default_name(args.infile)

    db = CompilationDatabase(args.infile, args.outfile)
    db.read()
    if os.path.isfile(args.extra_infile):
        db.read(open(args.extra_infile, 'r'))
    single = not args.multiple_file
    cmake_convertor = CmakeConverter(db, args.name, db.directory, single)
    cmake_convertor.convert()


if __name__ == '__main__':
    main()
