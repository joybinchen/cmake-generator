#!/usr/bin/env python
import argparse
import json
import os.path
import re
import shlex
import subprocess
import sys
import logging
FORMAT = '%(asctime)-15s %(levelname)-8s %(module)s %(message)s'
logging.basicConfig(format=FORMAT)
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
info = logger.info
debug = logger.debug
warn = logger.warning
error = logger.error

try:
    basestring
except NameError:
    basestring = str


def freeze(obj):
    if isinstance(obj, dict):
        return freeze(set([freeze(x) for x in obj.items()]))
    if isinstance(obj, list):
        return tuple([freeze(x) for x in obj])
    if isinstance(obj, set):
        return frozenset({freeze(x) for x in obj})
    if isinstance(obj, tuple):
        return tuple([freeze(x) for x in obj])
    return obj


def parsecommand(command, resolve):
    if (isinstance(command, basestring)):
        command = shlex.split(command)
    words = iter(command)
    compiler = next(words)  # remove the initial 'cc' / 'c++'

    options = []
    definitions = []
    includes = []
    system_includes = set()
    iquote_includes = set()
    lib_dirs = set()
    libs = set()
    linking = True
    target = ''

    for word in words:
        if word == '-o':
            target = next(words)
        elif word.startswith('-I'):
            include = word[2:]
            includes.append(resolve(include))
        elif word == '-isystem':
            include = next(words)
            include = resolve(include)
            if include not in includes:
                includes.append(include)
            system_includes.add(include)
        elif word == '-iquote':
            include = next(words)
            include = resolve(include)
            if include not in includes:
                includes.append(include)
            iquote_includes.add(include)
        elif word.startswith('-D'):
            define = word[2:]
            if define.find('=') > 0:
                name, value = define.split('=',1)
                if value:# and value.find(' ') >= 0:
                    define = '%s="%s"' % (name, value)
            definitions.append(define)
        elif word == '-c':
            linking = False
        elif word in ['-arch', '-include', '-x']:
            options.append(word)
            options.append(next(words))
        elif word in ['-MT', '-MF']:
            next(words)
        elif word.startswith('-L'):
            libs.add(word if len(word) > 2 else ('-L'+next(words)))
        elif word.startswith('-l'):
            libs.add(word[2:] or next(words))
        elif word in ['-g', '-O1', '-O2', '-O3']:
            continue
        elif word == '-O':
            next(words)
        elif word.startswith('-m'):
            options.append(word)
            libs.add(word)
        elif word.startswith('-'):
            options.append(word)

    return {
        'compiler': compiler,
        'libs': libs,
        'lib_dirs': lib_dirs,
        'options': options,
        'definitions': definitions,
        'includes': includes,
        'system_includes': system_includes,
        'iquote_includes': iquote_includes,
    }, target, linking


def get_include_path(include_path, source_dir):
    result = os.path.relpath(include_path, source_dir)
    # For paths that are not below the source root write the absolute path
    # to the CMakeLists instead of ../../../usr/local/include
    if os.path.isabs(include_path) and result.startswith(os.path.pardir):
        return include_path
    return result


class CompilationDatabase(object):
    used_names = {""}
    used_in_linking = {}
    disallowed_characters = re.compile("[^A-Za-z0-9_.+\-]")
    def __init__(self, infile, outfile):
        self.targets = {}
        self.sources = {}
        self.objects = {}
        self.linkings = {}
        self.input = infile
        self.output = outfile
        filename = os.path.realpath(self.output.name)
        if os.path.isfile(filename):
            self.cmake_filename = filename
            self.projectdir = os.path.dirname(filename) + '/'
        else:
            self.cmake_filename = 'autogenerated'
            self.projectdir = ''

    def relpath(self, path):
        if self.projectdir and path.startswith(self.projectdir):
            return path[len(self.projectdir):]
        return path

    def name_by_common_prefix(self, files):
        prefix = os.path.commonprefix(files)
        name = os.path.basename(prefix.rstrip("-_."))
        name = re.sub(self.disallowed_characters, "", name)
        return name

    def read(self):
        database = json.load(self.input)
        for entry in database:
            self.read_command(entry, entry['directory'])

    def read_command(self, entry, basedir):
        def resolve(path):
            if not os.path.isabs(path):
                path = os.path.join(basedir, path)
            return os.path.normcase(os.path.normpath(path))

        cmd = None
        if 'arguments' in entry.keys():
            cmd, target, linking = parsecommand(entry['arguments'], resolve)
        elif 'command' in entry.keys():
            cmd, target, linking = parsecommand(entry['command'], resolve)
        if cmd is None: return
        command = freeze(cmd)

        file_ = resolve(entry['file'])
        self.sources.setdefault(file_, {})[target] = command
        self.objects[target] = file_, command
        self.targets.setdefault(command, {}).setdefault(target, set()).add(file_)
        if not linking: return
        self.linkings.setdefault(target, {}).setdefault(command, set()).add(file_)

    def migrate_compilations(self, config, files, target):
        source_files = set()
        compilations = {}
        for f in files:
            if f in self.linkings or f not in self.objects:
                source_files.add(f)
                continue
            source, command = self.objects[f]
            compilations.setdefault(command, set()).add(source)
        if len(compilations) > 1:
            warn("find diferrent compile command to sources of target %s\n\t%s"
                    % (target, '\n\t'.join([cmd.str() for cmd in compilations])))
        for command, sources in compilations.items():
            for k, v in command:
                if not config.get(k): config[k] = v
            for source in sources:
                self.reduce_target(source, command, target)
                source_files.add(source)
        return source_files, config

    def reduce_target(self, source, command, target):
        config = {k: v for (k, v) in command}
        target_sources = self.targets.get(command, {}).get(target, set())
        if source in target_sources:
            debug("pop %s from source list of target %s" % (source, target))
            target_sources.remove(source)
            if not target_sources:
                self.targets[command].pop(target)
                cmd = config['compiler'] + ' ' +' '.join(config['options'])
                cmd = '\n'.join(["%s: %s"%(k,v) for k,v in command])
                debug("pop %s from targets of command\n%s" % (target, cmd))
        else:
            warn("file %s not in source list of target %s" % (source, target))

    def output_linked_target(self, name, command, files, target):
        config = {k: v for (k, v) in command}
        source_files, config = self.migrate_compilations(config, files, name)
        debug("linked objects for %s\n\t%s" % (target, '\n\t'.join(files)))
        info("output linked target: %s for \t%s\n\t%s" % (
            name, target, '\n\t'.join(source_files)))
        self.output_cmake_target(name, config, source_files, executable=True)

    def write_command(self, command, options, name, parts, single_line=None):
        if single_line is None: single_line = ' '.join(parts) < 40
        delimetor = ' ' if single_line else '\n    '
        content = delimetor + (delimetor.join(parts)) + (delimetor[0])
        self.output.write('%s(%s %s%s)\n\n' % (command, name, options, content))

    def output_includes(self, options, name, parts): 
        if not parts: return
        if self.projectdir:
            parts = [get_include_path(include, self.projectdir) for include in parts]
        self.write_command('target_include_directories', options, name, parts)

    def output_compile_args(self, arg_type, name, config): 
        parts = config.get(arg_type)
        debug("output compile args %s for target %s: %s" % (arg_type, name, parts))
        if not parts: return
        self.write_command('target_compile_' + arg_type, 'PRIVATE', name, parts)

    def write(self, name='autogenerated'):
        self.output.write('cmake_minimum_required(VERSION 2.8.8)\n')
        info("write project %s in directory \t%s" % (name, self.projectdir))
        self.output.write('project({} LANGUAGES C CXX)\n\n'.format(name))

        for (target, command_source) in self.linkings.items():
            commands = command_source.keys()
            if len(commands) > 1:
                warn("target %s created by multiple command:\n%s" % (
                    target, commands))
            for config, files in command_source.items():
                name = self.relpath(target).replace('/', '.')
                name = re.sub(self.disallowed_characters, "", name)
                self.output_linked_target(name, config, files, target)
        for (config, target_group) in self.targets.items():
            files = set()
            for target, srcs in target_group.items():
                if target in self.linkings: continue
                for f in srcs:
                    command = self.sources.get(f, {}).get(target, None)
                    if command is None: continue
                    if command != config:
                        warn("target %s generated by diferent command:\n\t%s\n\t%s"%(
                            target, command, config))
                    files.add(f)
            if not files: continue

            name = self.name_by_common_prefix(files)
            info("output unlinked library target: %s for command\n%s\n\t%s" % (
                name, '\n'.join("%s: %s"%(k,v) for (k, v) in config), '\n\t'.join(files)))
            self.output_library(name, config, files)

    def output_library(self, name, command, files):
        config = {k: v for (k, v) in command}
        self.output_cmake_target(name, config, files, executable=False)

    def output_cmake_target(self, name, config, files, executable=False):
        files = [self.relpath(f) for f in files]
        debug("write target %s for files=\n\t%s" % (name, '\n\t'.join(files)))
        if name in self.used_names:
            index = 2
            while True:
                candidate = '{}_{}'.format(name, index)
                if candidate not in self.used_names:
                    name = candidate
                    break
                index = index + 1
        self.used_names.add(name)
        target_type = None if executable else 'OBJECT'
        self.output_target(name, config, files, target_type)

    def output_target(self, name, config, files, libtype='OBJECT'):
        if not files or not name: return
        if libtype:
            self.write_command('add_library', libtype, name, files)
        else:
            self.write_command('add_executable', '', name, files)
        self.output_target_config(name, config)

    def output_target_libs(self, name, config):
        libs = config.get('libs')
        self.write_command('target_link_libraries', 'PRIVATE', name, libs)

    def output_target_config(self, name, config):
        self.output_compile_args('options', name, config)
        self.output_compile_args('definitions', name, config)
        self.output_includes('PRIVATE', name, config.get('includes'))
        self.output_includes('SYSTEM PRIVATE', name, config.get('system_includes'))
        self.output_includes('BEFORE PRIVATE', name, config.get('iquote_includes'))
        self.output_target_libs(name, config)


def get_default_name(compilation_database):
    filename = os.path.realpath(compilation_database.name)
    if not os.path.isfile(filename):
        return 'autogenerated'
    projectdir = os.path.dirname(filename)
    try:
        output = subprocess.Popen(
            ['git', 'rev-parse', '--show-toplevel'],
            cwd=projectdir, stdout=subprocess.PIPE).communicate()[0]
        output = output.strip()
        return os.path.basename(output)
    except Exception:
        return 'autogenerated'


def main():
    parser = argparse.ArgumentParser(description="""
        Convert a compile_commands.json file to a CMakeLists.txt file.
    """)

    infile = 'compile_commands.json' if os.isatty(sys.stdin.fileno()) else '-'
    parser.add_argument(
        'infile', nargs='?', type=argparse.FileType('r'), default=infile,
        help="""
path of the compilation database (default: compile_commands.json or stdin)
        """
    )
    outfile = 'CMakeLists.txt' if os.isatty(sys.stdout.fileno()) else '-'
    parser.add_argument(
        'outfile', nargs='?', type=argparse.FileType('w'), default=outfile,
        help="""
path of the CMake file (default: CMakeLists.txt or stdout)
        """
    )

    parser.add_argument(
        '-n', '--name', help="""
name of the CMake project (default: taken from Git root, or 'autogenerated')
        """
    )
    parser.add_argument(
        '-d', '--debug', action='store_true', default=False, help="""
enable debug log output
        """
    )
    args = parser.parse_args()
    if args.debug:
        logger.setLevel(logging.DEBUG)

    if args.name is None:
        args.name = get_default_name(args.infile)

    database = CompilationDatabase(args.infile, args.outfile)
    database.read()
    database.write(name=args.name)


if __name__ == '__main__':
    main()
