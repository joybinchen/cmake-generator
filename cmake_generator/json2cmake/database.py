import os
import logging

import shlex
import json
from .utils import *
from .denpendency import find_dependencies
from .migration import migrate_install_commands
from .command import CompileCommand


logger, info, debug, warn, error = get_loggers(__name__)


class CompilationDatabase(PathUtils):
    def __init__(self, infile):
        super(self.__class__, self).__init__('')
        # targets: {cmd_id: {target: {source, ...}, ...}, ...}
        self.targets = {}
        # sources: {source: {target: cmd_id, ...}, ...}
        self.sources = {}
        # objects: {target: {source: cmd_id, ...}, ...}
        self.objects = {}
        # linkings: {target: {cmd_id: {object_file, ...}, ...}, ...}
        self.linkings = {}
        # installs: {cmd_id: {destination: {target, ...}, ...}, ...}
        self.installs = {}
        self.install_command = []
        self.command = []
        self.input = infile
        filename = os.path.realpath(infile.name)
        if os.path.isfile(filename):
            self.cmake_filename = filename
            self.set_directory(os.path.dirname(filename))
        else:
            self.cmake_filename = 'autogenerated'
            self.directory = ''

    def command_linkage(self, cmd_id):
        return self.command[cmd_id].linkage

    def target_linkage(self, f):
        command_sources = self.linkings[f]
        if not command_sources:
            return None
        if len(command_sources) > 1:
            warn("find multiple command creating the same target: %s" % f)
        cmd_id = next(iter(command_sources.keys()))
        return self.command_linkage(cmd_id)

    def command_cwd(self, cmd_id):
        return self.command[cmd_id].cwd

    def is_generated(self, source):
        if source in self.linkings:
            command_sources = self.db.linkings[source]
            for cid in command_sources.keys():
                if self.command_linkage(cid) == 'SOURCE':
                    return True

    def parse_command(self, command_line, cwd, file_, root_dir):
        if isinstance(command_line, basestring):
            command_line = shlex.split(command_line)
        words = iter(command_line)
        compiler = os.path.basename(next(words))  # remove the initial 'cc' / 'c++'
        if compiler.startswith('python'):
            compiler = os.path.basename(next(words))

        command = CompileCommand(compiler, cwd)
        target = command.parse_command(words, file_, root_dir)
        return command, target

    def read(self, infile=None):
        if infile is None:
            infile = self.input
        database = json.load(infile)
        cmd_dict = {}
        install_cmd_dict = {}
        for entry in database:
            self.read_command(entry, cmd_dict, install_cmd_dict)

    def read_command(self, entry, cmd_dict, install_cmd_dict):
        cwd = entry.get('directory', self.directory)
        file_ = self.resolve(entry['file'], cwd)
        arguments = shlex.split(entry.get('command', ''))
        arguments = entry.get('arguments', arguments)
        cmd, target = self.parse_command(arguments, cwd, file_, self.directory)
        if not cmd:
            return cmd

        target = self.resolve(target, cwd)
        linkage = cmd.linkage
        if linkage == 'INSTALL':
            self.update_install_index(target, cmd, file_, install_cmd_dict)
            return cmd

        cmd_id = self.update_command_index(cmd, cmd_dict, self.command, debug)
        self.update_target_index(target, cmd_id, file_, linkage)
        if linkage == 'OBJECT':
            missing_depends = find_dependencies(file_, cmd, self.directory)
            if missing_depends:
                info("cmd #%s created OBJECT %-25s depends on missing %s"
                     % (cmd_id, self.relpath(target), ' '.join([self.relpath(f) for f in missing_depends])))
                self.command[cmd_id].missing_depends.update(missing_depends)
                self.command[cmd_id].include_binary_dir = True
        return cmd

    @staticmethod
    def update_command_index(cmd, cmd_dict, cmd_list, log=None):
        freezed_cmd = freeze(cmd)
        cmd_id = cmd_dict.get(freezed_cmd)
        if cmd_id is None:
            cmd_id = len(cmd_list)
            cmd_dict[freezed_cmd] = cmd_id
            cmd_list.append(cmd)
            cmd.id = cmd_id
            if log:
                log('New cmd #%s: %s' % (cmd_id, '\n'.join(["%-10s %s" % x for x in freezed_cmd])))
        return cmd_id

    def update_install_index(self, target, cmd, file_, cmd_dict):
        cmd_id = self.update_command_index(cmd, cmd_dict, self.install_command)
        debug("Install cmd #%s install %-27s => %s"
              % (cmd_id, self.relpath(file_), self.relpath(target)))
        self.installs.setdefault(cmd_id, {})[target] = file_

    def update_target_index(self, target, cmd_id, file_, linkage):
        debug("entry %-35s cmd #%s => %-10s %s"
              % (self.relpath(file_), cmd_id, linkage, self.relpath(target)))
        self.sources.setdefault(file_, {})[target] = cmd_id
        self.objects.setdefault(target, {})[file_] = cmd_id
        self.targets.setdefault(cmd_id, {}).setdefault(target, set()).add(file_)
        if linkage not in ('OBJECT', 'LOCALE', None):
            self.update_linking_index(target, cmd_id, file_)

    def update_linking_index(self, target, cmd_id, file_):
        debug("Add linked target %s from %s"
              % (self.relpath(target), self.relpath(file_)))
        self.linkings.setdefault(target, {}).setdefault(cmd_id, set()).add(file_)

    def extract_migrated_commands(self):
        migratables = [(cmd_id, tuple(x.keys())[0], tuple(x.values())[0]) for cmd_id, x in
                       (filter(lambda x: len(x[1]) == 1, self.installs.items()))]
        for cmd_id, _, _ in migratables:
            self.installs.pop(cmd_id)
        return migrate_install_commands(migratables, self.install_command, ('destination', 'id'))


if __name__ == '__main__':
    # FORMAT = '%(asctime)-15s %(levelname)-8s %(module)s %(message)s'
    FORMAT = '%(levelname)-8s %(lineno)5d %(message)s'
    logging.basicConfig(format=FORMAT)
